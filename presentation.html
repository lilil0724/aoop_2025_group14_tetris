<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Battle Project Presentation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f4f4f9;
        }

        .slide {
            background: white;
            padding: 40px;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #2c3e50;
        }

        h1,
        h2,
        h3 {
            color: #2c3e50;
        }

        h1 {
            text-align: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        h2 {
            margin-top: 0;
            color: #3498db;
        }

        ul {
            padding-left: 20px;
        }

        li {
            margin-bottom: 10px;
        }

        code {
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            color: #e74c3c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .mermaid {
            text-align: center;
            background-color: #fff;
            padding: 10px;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .comparison-table th,
        .comparison-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        .comparison-table th {
            background-color: #f2f2f2;
            color: #333;
        }

        .highlight {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
    </style>
    <!-- Mermaid JS for rendering diagrams -->
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
    </script>
</head>

<body>

    <div class="slide">
        <h1>Tetris Battle - 專案簡報</h1>
        <p style="text-align: center; font-size: 1.2em; color: #666;">Group 14</p>
    </div>

    <div class="slide">
        <h2>1. 遊戲介紹 (Introduction)</h2>
        <h3>專案概述</h3>
        <p>這是一個基於 Python 和 Pygame 開發的俄羅斯方塊對戰遊戲 (Tetris Battle)。除了經典的單人模式外，重點在於實現多人對戰與 AI 對戰功能。</p>

        <h3>主要特色</h3>
        <ul>
            <li><strong>多種遊戲模式</strong>：
                <ul>
                    <li><strong>SOLO</strong>: 單人練習模式</li>
                    <li><strong>PVP (Local)</strong>: 本地雙人對戰</li>
                    <li><strong>LAN (Network)</strong>: 區域網路連線對戰</li>
                    <li><strong>PVE (AI)</strong>: 與電腦 AI 進行對戰</li>
                </ul>
            </li>
            <li><strong>對戰機制</strong>：包含垃圾行 (Garbage Lines) 攻擊系統、B2B (Back-to-Back) 加成。</li>
            <li><strong>現代化機制</strong>：7-Bag 方塊生成、Ghost Piece (落點預測)、Hold 功能。</li>
        </ul>
    </div>

    <div class="slide">
        <h2>2. 系統架構 (System Architecture)</h2>
        <h3>開發環境</h3>
        <ul>
            <li><strong>語言</strong>: Python 3.11</li>
            <li><strong>核心函式庫</strong>: Pygame (圖形介面與事件處理)</li>
            <li><strong>其他工具</strong>: Numpy (AI 矩陣運算), Socket (網路連線)</li>
        </ul>

        <h3>專案結構</h3>
        <ul>
            <li><code>main.py</code>: 程式入口，負責初始化與場景切換。</li>
            <li><code>game_engine.py</code>: 核心遊戲迴圈，管理遊戲狀態。</li>
            <li><code>pieces.py</code> & <code>shots.py</code>: 定義方塊與棋盤資料結構。</li>
            <li><code>Handler.py</code>: 負責方塊移動、旋轉與碰撞檢測邏輯。</li>
            <li><code>ai_*.py</code>: AI 演算法實作。</li>
            <li><code>ui.py</code> & <code>menus.py</code>: 使用者介面與選單系統。</li>
        </ul>
    </div>

    <div class="slide">
        <h2>3. OOP Class Diagram (類別圖)</h2>
        <div class="mermaid">
            classDiagram
            direction TB

            %% Layer 1 (Top): Entry point
            class Main {
            +main()
            }

            %% Layer 2: Game loop / orchestration (module)
            class game_engine {
            +run_game(...)
            +get_new_bag()
            }

            %% Layer 3: Per-player runtime context (inner class)
            class PlayerContext {
            +Shot shot
            +Piece piece
            +Piece next_piece
            +list bag
            +bool is_ai
            +bool is_local
            +str name
            +object ai_agent
            }

            %% Layer 4: Data objects & services
            class Shot {
            +list status
            +list color
            +int score
            +int line_count
            +int pending_garbage
            +int combo_count
            +bool is_b2b
            }

            class Piece {
            +int x
            +int y
            +str shape
            +int rotation
            +tuple color
            +bool is_fixed
            +getCells()
            }

            class Handler {
            +moveLeft(shot, piece)
            +moveRight(shot, piece)
            +drop(shot, piece)
            +instantDrop(shot, piece)
            +rotate(shot, piece)
            +rotateCCW(shot, piece)
            +fixPiece(shot, piece)
            +eliminateFilledRows(shot, piece)
            +calculateAttack(...)
            +insertGarbage(shot, lines_to_add)
            -_can_move(shot, piece, dx, dy)
            }

            class Button {
            +rect
            +text
            +draw(screen)
            +is_clicked(event)
            }

            class WeightedAI {
            +weights : list
            +get_best_move(board, piece)
            +get_features(board)
            }

            Main --> GameEngine : Calls
            GameEngine *-- PlayerContext : Manages
            PlayerContext o-- Piece : Has Current/Next
            PlayerContext o-- Shot : Has Board State
            PlayerContext ..> Handler : Uses for Logic
            GameEngine ..> Button : Uses in UI
            PlayerContext o-- WeightedAI : Uses Strategy
        </div>
    </div>

    <div class="slide">
        <h2>4. 核心類別說明 (Key Classes)</h2>
        <ul>
            <li><strong>Piece (方塊)</strong>: 代表一個正在掉落的俄羅斯方塊。屬性包含座標、形狀、旋轉狀態。</li>
            <li><strong>Shot (棋盤狀態)</strong>: 儲存遊戲盤面的靜態數據 (status 陣列) 與玩家狀態 (分數、垃圾行)。</li>
            <li><strong>Handler (邏輯處理器)</strong>: 包含多個靜態方法 (Static Methods)，如 <code>moveLeft</code>,
                <code>rotate</code>，將邏輯與資料分離。
            </li>
        </ul>
    </div>

    <div class="slide">
        <h2>5. AI 演算法選擇與比較</h2>

        <div class="highlight">
            <h3>為什麼選擇 Weighted Heuristic (權重啟發式)？</h3>
            <p>在本專案中，我們選擇了基於特徵權重的啟發式演算法，而非深度強化學習 (如 DQN 或 CNN)，原因如下：</p>
        </div>

        <table class="comparison-table">
            <thead>
                <tr>
                    <th>比較項目</th>
                    <th>Weighted Heuristic (本專案採用)</th>
                    <th>Deep RL (DQN / CNN)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>可解釋性 (Explainability)</strong></td>
                    <td><strong>高</strong>。我們可以清楚知道 AI 是因為「想要降低高度」或「避免空洞」而做出決策。</td>
                    <td><strong>低</strong>。神經網路是黑盒子，難以理解為何在特定情況下做出某個操作。</td>
                </tr>
                <tr>
                    <td><strong>運算效能 (Performance)</strong></td>
                    <td><strong>極快</strong>。僅需簡單的矩陣運算，適合在 Python 中即時運行 (60 FPS)。</td>
                    <td><strong>較慢</strong>。需要大量的矩陣乘法與推論，若無 GPU 加速可能導致遊戲延遲。</td>
                </tr>
                <tr>
                    <td><strong>訓練難度 (Training)</strong></td>
                    <td><strong>低</strong>。可以使用遺傳演算法 (Genetic Algorithm) 快速收斂出最佳權重。</td>
                    <td><strong>極高</strong>。需要數百萬次的訓練回合 (Episodes)，且容易發生「災難性遺忘」。</td>
                </tr>
                <tr>
                    <td><strong>狀態空間 (State Space)</strong></td>
                    <td>透過特徵提取 (Feature Extraction) 大幅簡化了狀態空間。</td>
                    <td>直接處理原始像素或網格，狀態空間過於龐大，收斂困難。</td>
                </tr>
            </tbody>
        </table>

        <h3>實作細節</h3>
        <p>AI 透過評估當前盤面的特徵來決定最佳落點：</p>
        <ul>
            <li><strong>Landing Height</strong>: 落點高度 (越低越好)</li>
            <li><strong>Holes</strong>: 空洞數量 (越少越好)</li>
            <li><strong>Row Transitions</strong>: 表面平整度 (越平整越好)</li>
            <li><strong>Well Depth</strong>: 豎井深度 (適度保留以消四排)</li>
        </ul>
    </div>

    <div class="slide">
        <h2>6. 結論 (Conclusion)</h2>
        <ul>
            <li>本專案成功實作了一個功能完整的俄羅斯方塊對戰遊戲。</li>
            <li>運用 OOP 物件導向設計，使程式碼結構清晰，易於擴充。</li>
            <li>選擇了最適合專案規模的 AI 演算法，在效能與強度之間取得平衡。</li>
        </ul>
    </div>

</body>

</html>